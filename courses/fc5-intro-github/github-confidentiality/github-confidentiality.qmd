---
title: Handling Confidential & Sensitive Data on Git & GitHub
---

::: {.unit-overview}
# Overview
Public Git histories are **immutable** and globally visible. Accidentally pushing passwords, API keys, patient data, or proprietary code can cause legal and security disasters.  
This unit covers policies and tooling to keep secrets secret while still leveraging GitHub workflows.
:::

::: {.unit-goals}
# Goals
* Identify data that must never enter a Git repository  
* Use **`.gitignore`** and secret‑scanning hooks to prevent leaks  
* Store credentials safely with **GitHub Secrets** and environment files  
* Remove sensitive data from history with BFG or `git filter‑repo`  
* Implement end‑to‑end encryption (git‑crypt, SOPS) when required
:::

::: {.unit-reading}
# Reading

## 1  Classify your assets

| Data type | Recommended location |
|-----------|----------------------|
| API tokens, passwords | Secret manager / CI secrets |
| PHI/PII (HIPAA, GDPR) | Encrypted external store; never Git |
| Proprietary binary files | Private object storage or LFS |
| Configuration templates | Repo (sanitized), plus CI secrets |

## 2  Prevent leaks proactively

### `.gitignore`

Add common patterns:

```
.Rhistory
*.pem
*.key
.env
```

### Pre‑commit hooks

Tool: **pre‑commit + detect‑secrets**

```yaml
repos:
  - repo: https://github.com/Yelp/detect-secrets
    rev: v1.4.0
    hooks:
      - id: detect-secrets
```

### GitHub secret scanning

GitHub automatically scans pushes and PRs for 200+ token patterns.  
Enterprise users can add custom regex detectors.

## 3  Storing secrets for CI/CD

* **GitHub Actions** – `Settings → Secrets and variables`  
  ```yaml
  env:
    AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  ```
* Limit scopes (principle of least privilege).  
* Rotate keys periodically and audit usage.

## 4  Removing leaked secrets

1. **Revoke** the token immediately.  
2. Rewrite history:  
   ```bash
   bfg --delete-files id_rsa
   bfg --replace-text passwords.txt
   git push --force --all
   ```
3. Inform collaborators to re‑clone.

## 5  Encrypting at rest

* **git‑crypt** – transparent AES encryption of selected paths; keys shared with GPG.  
* **Mozilla SOPS** – declarative YAML/JSON files encrypted with KMS or PGP.

## Summary

A robust confidentiality workflow combines **preventive filtering**, **centralised secret stores**, and **emergency cleanup tooling**. Automate checks so that sensitive data never reaches origin.
:::

::: {.unit-resources}
# Further resources

* **GitHub Docs: Secret scanning**  
* **pre‑commit detect‑secrets** – <https://github.com/Yelp/detect-secrets>  
* **BFG Repo‑Cleaner** – <https://github.com/rtyley/bfg-repo-cleaner>  
* **git‑crypt** – <https://github.com/AGWA/git-crypt>  
* **SOPS** – <https://github.com/mozilla/sops>
:::

::: {.unit-exercise}
# Practice

1. Create a `.env` file with fake credentials; configure `detect‑secrets` to block commits containing it.  
2. Accidentally commit the file, observe the pre‑commit hook failure, then fix it.  
3. Simulate a leak: commit a dummy AWS key, push, and watch GitHub secret‑scanning flag it.  
4. Use BFG to scrub the key from history and force‑push the cleaned branch.
:::
