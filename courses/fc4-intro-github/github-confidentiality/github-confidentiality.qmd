---
title: Handling Confidential and Sensitive Data
subtitle: ""
---

::: {.unit-overview}
# Overview

Public Git histories are immutable and globally visible. Accidentally pushing passwords, API keys, patient data, or proprietary code can cause legal and security disasters. This unit covers policies and tooling to keep secrets secret while still leveraging GitHub workflows.

:::
<!-- end unit-overview div -->

::: {.unit-goals}
# Goals

* Identify data that must never enter a Git repository.
* Use `.gitignore` and secret scanning to prevent leaks.
* Store credentials safely with GitHub Secrets and environment files.
* Remove sensitive data from history when mistakes happen.

:::
<!-- end unit-goals div -->

<!--
::: {.unit-video}
# Video, slides and audio transcript

Below is the video for this unit. Here are [the slides shown in the video](), and here is the [audio transcript](), as well as a [text version of the transcript]().

<iframe class="video" src="https://www.youtube.com/embed/VIDEO_ID" title="Handling Confidential and Sensitive Data" allowfullscreen></iframe>

:::
-->
<!-- end unit-video div -->


::: {.unit-reading}
# Reading

## Introduction

The main principle when working with GitHub is that by default **everything you put in a Git repository is public and permanent**. This can cause a problem for confidential or sensitive data. The next sections discuss best practices for dealing with confidential information while using GitHub.


## Anonymizing data

Often, the parts of the data you need for modeling and analysis don't need to contain confidential or identifying information, like names or dates of birth. It is often a good idea to process your raw data to remove or anonymize such information before putting it into a Git repository. Once you have done that, you can put the anonymized data into a repository. If you want to be extra safe, you might want to opt for a private repository (see next section). If you put it in a public repository, be **very careful** that you only make things public that are ok to be made public.


## Using a private repo

As mentioned, the default for GitHub is to have repositories that are publicly viewable by anyone. However, it is easy to set up a private repository. Private repositories are only viewable by you and people you explicitly give access to. This is a good option if you need to work with sensitive data that cannot be anonymized. Note that private repositories are not free unless you have a GitHub Pro account (which is free for students via the GitHub Student Developer Pack). If you are working in an organization (e.g., your university or company), they might have a GitHub Enterprise account that allows for private repositories.

You can switch repositories from public to private and vice versa in the repository settings on GitHub. However, be careful when switching from private to public. Make sure that no sensitive data is in the repository before making it public.


## Keeping files local

It might be that you do need to work with data that cannot be anonymized and that you cannot or don't want to put into a private repository. In that case, you should keep such data files outside of your Git repository. You can still use GitHub for your code and non-sensitive files, but keep the sensitive files on your local machine only. You can then load the sensitive data from your local machine when running your code. This way, the sensitive data never enters the Git repository.

Git allows you to specify certain files and folders that are not being tracked, and thus not being pushed to your repository on GitHub.com. This is done via a special file called `.gitignore` placed in the root of your repository. You can add patterns to this file to exclude files or directories that contain sensitive information. For instance, if you have a raw data folder that you want to not track with Git/GitHub, you would place this into your `.gitignore` file:
```
data/raw/
```
This would exclude the entire `raw` folder inside the `data` folder from being tracked by Git. You can add as many patterns as you want to the `.gitignore` file. 

An important drawback of this approach is that if you work on multiple machines, or work with collaborators, everyone needs to make sure to have the same sensitive files outside of the repository on their local machines. This can be a logistical challenge.

A possible workaround is to place these files into another Sync service, such as Dropbox, OneDrive, or Google Drive that you consider to be safe. You can then load the files from there when running your code. This way, the sensitive files are not in the Git repository, but you can still share them with collaborators via the Sync service. (This approach also works well for large files that you can't sync with Git/GitHub.)



:::{.warning}
Remember that Git tracks the full project history. So if at any time you added a file with sensitive information, even if you delete it later, it's still in the history and can be found. If that happens, you basically need to completely delete the GitHub repository (after copying all important files to a safe location) and starting over with a new repository, taking care to keep sensitive files out of this new repor.
:::



:::
<!-- end unit-reading div -->


::: {.unit-summary}
# Summary


:::
<!-- end unit-summary div -->


::: {.unit-resources}
# Further Resources


:::
<!-- end unit-resources div -->


<!--
::: {.unit-quiz}
# Test yourself

```{r github-confidentiality-quiz}
#| echo: false
#| results: "asis"
# quizzes <- list("github-confidentiality-quiz-1.Rmd", "github-confidentiality-quiz-2.Rmd", "github-confidentiality-quiz-3.Rmd")
# exams2forms::exams2forms(file = quizzes, title = 'github-confidentiality-quiz')
```
:::
-->
<!-- end unit-quiz div -->


::: {.unit-exercise}
# Practice

1. Add a `.gitignore` with common secret patterns.
2. Set a fake API key as an environment variable and confirm it is not committed.
3. If you have a test repo, simulate a leak and practice removing it with `git filter-repo` or BFG.

:::
<!-- end unit-exercise div -->
