---
title: Managing Large Files with Git and GitHub
subtitle: ""
---

::: {.unit-overview}
# Overview

Plain Git stores every version of every file. That makes large or binary assets (genomic FASTQs, high-resolution images, video, model weights) explode your repository size and slow down every clone. This unit shows strategies to keep history lean while preserving reproducibility.

:::
<!-- end unit-overview div -->

::: {.unit-goals}
# Goals

* Understand why vanilla Git struggles with large or binary files.
* Configure and use Git Large File Storage (LFS).
* Compare LFS with alternative storage approaches.
* Apply best practices for dataset versioning.

:::
<!-- end unit-goals div -->

<!--
::: {.unit-video}
# Video, slides and audio transcript

Below is the video for this unit. Here are [the slides shown in the video](), and here is the [audio transcript](), as well as a [text version of the transcript]().

<iframe class="video" src="https://www.youtube.com/embed/VIDEO_ID" title="Managing Large Files with Git and GitHub" allowfullscreen></iframe>

:::
-->
<!-- end unit-video div -->


::: {.unit-reading}
# Reading

## Force push

::: note
Sometimes, there might be issues that prevent pushing/pulling, e.g., if someone else changed the same files you did. If you are sure your local version is the correct one, you can perform a **force push**. A force push will overwrite the remote repo with the local repo forcibly. This means that the remote will be updated with any changes that exist on your local computer. If any changes have been made to the code since you began editing (i.e. someone else has made a commit to the repo while you were working on it) they will be **destroyed** by the force push since they are not on your local repo. For this assignment, you are the only person working on your introduction so it is unlikely you will encounter any issues with force push, but it is good to be aware of the function of the action. Use with care. It's generally better to [resolve merge conflicts.](https://www.gitkraken.com/learn/git/tutorials/how-to-resolve-merge-conflict-in-git)
:::


## Large files


:::
<!-- end unit-reading div -->


::: {.unit-summary}
# Summary

Git LFS (or similar tools) lets you keep code and data under one logical roof without bloating your repo. Adopt it early and automate retrieval in workflows.

:::
<!-- end unit-summary div -->


::: {.unit-resources}
# Further Resources

* **Git LFS docs** – <https://git-lfs.github.com/>
* **DVC** – <https://dvc.org/>
* **GitHub Docs: Working with Large Files** – <https://docs.github.com/github/managing-large-files>
* **BFG Repo-Cleaner** – <https://rtyley.github.io/bfg-repo-cleaner/>

:::
<!-- end unit-resources div -->


<!--
::: {.unit-quiz}
# Test yourself

```{r github-further-topics-quiz}
#| echo: false
#| results: "asis"
# quizzes <- list("github-further-topics-quiz-1.Rmd", "github-further-topics-quiz-2.Rmd", "github-further-topics-quiz-3.Rmd")
# exams2forms::exams2forms(file = quizzes, title = 'github-further-topics-quiz')
```
:::
-->
<!-- end unit-quiz div -->


::: {.unit-exercise}
# Practice

1. Identify one large file in a project and decide whether it should live in Git.
2. If it should be tracked, set up Git LFS for its file type.
3. Commit a small LFS-tracked file and verify it appears as a pointer file in the repo.

:::
<!-- end unit-exercise div -->
