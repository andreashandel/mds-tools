---
title: Further Topics
subtitle: ""
---

::: {.unit-overview}
# Overview

In this unit, we discuss a few additional topics related to Git/GitHub that are worth mentioning in the context of modeling and data science work.

:::
<!-- end unit-overview div -->

::: {.unit-goals}
# Goals

* Be aware of the concept of merge conflicts and how to handle them.
* Know how to deal with potential confidentiality issues when using Git/GitHub.


:::
<!-- end unit-goals div -->

<!--
::: {.unit-video}
# Video, slides and audio transcript

Below is the video for this unit. Here are [the slides shown in the video](), and here is the [audio transcript](), as well as a [text version of the transcript]().

<iframe class="video" src="https://www.youtube.com/embed/VIDEO_ID" title="Managing Large Files with Git and GitHub" allowfullscreen></iframe>

:::
-->
<!-- end unit-video div -->


::: {.unit-reading}
# Reading



## Merge conflicts

## Force push

::: note
Sometimes, there might be issues that prevent pushing/pulling, e.g., if someone else changed the same files you did. If you are sure your local version is the correct one, you can perform a **force push**. A force push will overwrite the remote repo with the local repo forcibly. This means that the remote will be updated with any changes that exist on your local computer. If any changes have been made to the code since you began editing (i.e. someone else has made a commit to the repo while you were working on it) they will be **destroyed** by the force push since they are not on your local repo. For this assignment, you are the only person working on your introduction so it is unlikely you will encounter any issues with force push, but it is good to be aware of the function of the action. Use with care. It's generally better to [resolve merge conflicts.](https://www.gitkraken.com/learn/git/tutorials/how-to-resolve-merge-conflict-in-git)
:::


## Large files


## Confidentiality

## Introduction

The main principle when working with GitHub is that by default **everything you put in a Git repository is public and permanent**. This can cause a problem for confidential or sensitive data. The next sections discuss best practices for dealing with confidential information while using GitHub.


## Anonymizing data

Often, the parts of the data you need for modeling and analysis don't need to contain confidential or identifying information, like names or dates of birth. It is often a good idea to process your raw data to remove or anonymize such information before putting it into a Git repository. Once you have done that, you can put the anonymized data into a repository. If you want to be extra safe, you might want to opt for a private repository (see next section). If you put it in a public repository, be **very careful** that you only make things public that are ok to be made public.


## Using a private repo

As mentioned, the default for GitHub is to have repositories that are publicly viewable by anyone. However, it is easy to set up a private repository. Private repositories are only viewable by you and people you explicitly give access to. This is a good option if you need to work with sensitive data that cannot be anonymized. Note that private repositories are not free unless you have a GitHub Pro account (which is free for students via the GitHub Student Developer Pack). If you are working in an organization (e.g., your university or company), they might have a GitHub Enterprise account that allows for private repositories.

You can switch repositories from public to private and vice versa in the repository settings on GitHub. However, be careful when switching from private to public. Make sure that no sensitive data is in the repository before making it public.


## Keeping files local

It might be that you do need to work with data that cannot be anonymized and that you cannot or don't want to put into a private repository. In that case, you should keep such data files outside of your Git repository. You can still use GitHub for your code and non-sensitive files, but keep the sensitive files on your local machine only. You can then load the sensitive data from your local machine when running your code. This way, the sensitive data never enters the Git repository.

Git allows you to specify certain files and folders that are not being tracked, and thus not being pushed to your repository on GitHub.com. This is done via a special file called `.gitignore` placed in the root of your repository. You can add patterns to this file to exclude files or directories that contain sensitive information. For instance, if you have a raw data folder that you want to not track with Git/GitHub, you would place this into your `.gitignore` file:
```
data/raw/
```
This would exclude the entire `raw` folder inside the `data` folder from being tracked by Git. You can add as many patterns as you want to the `.gitignore` file. 

An important drawback of this approach is that if you work on multiple machines, or work with collaborators, everyone needs to make sure to have the same sensitive files outside of the repository on their local machines. This can be a logistical challenge.

A possible workaround is to place these files into another Sync service, such as Dropbox, OneDrive, or Google Drive that you consider to be safe. You can then load the files from there when running your code. This way, the sensitive files are not in the Git repository, but you can still share them with collaborators via the Sync service. (This approach also works well for large files that you can't sync with Git/GitHub.)



:::{.warning}
Remember that Git tracks the full project history. So if at any time you added a file with sensitive information, even if you delete it later, it's still in the history and can be found. If that happens, you basically need to completely delete the GitHub repository (after copying all important files to a safe location) and starting over with a new repository, taking care to keep sensitive files out of this new repor.
:::





:::
<!-- end unit-reading div -->


::: {.unit-summary}
# Summary

Git LFS (or similar tools) lets you keep code and data under one logical roof without bloating your repo. Adopt it early and automate retrieval in workflows.

:::
<!-- end unit-summary div -->


::: {.unit-resources}
# Further Resources

* **Git LFS docs** – <https://git-lfs.github.com/>
* **DVC** – <https://dvc.org/>
* **GitHub Docs: Working with Large Files** – <https://docs.github.com/github/managing-large-files>
* **BFG Repo-Cleaner** – <https://rtyley.github.io/bfg-repo-cleaner/>

:::
<!-- end unit-resources div -->


<!--
::: {.unit-quiz}
# Test yourself

```{r github-further-topics-quiz}
#| echo: false
#| results: "asis"
# quizzes <- list("github-further-topics-quiz-1.Rmd", "github-further-topics-quiz-2.Rmd", "github-further-topics-quiz-3.Rmd")
# exams2forms::exams2forms(file = quizzes, title = 'github-further-topics-quiz')
```
:::
-->
<!-- end unit-quiz div -->


::: {.unit-exercise}
# Practice

1. Identify one large file in a project and decide whether it should live in Git.
2. If it should be tracked, set up Git LFS for its file type.
3. Commit a small LFS-tracked file and verify it appears as a pointer file in the repo.

:::
<!-- end unit-exercise div -->
